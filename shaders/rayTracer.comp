#version 430 core

#define MAX_VAL pow(10,5.f)

layout(local_size_x = 1, local_size_y = 1) in; // the workload of a job is at pixel level
layout(rgba32f, binding = 0) uniform image2D renderOut;  // pass in blank texture to modify

uniform mat4 M_film2World;
uniform vec4 eye;
uniform int depth;
uniform int width;
uniform int height;
uniform float time;

#define PLANE  0
#define SPHERE 1


struct Ray {
	vec4 P; 
	vec4 d;
};

struct SurfaceElement {
	float t;
	vec4 intersection; // world space intersect
	vec4 normal;
	
	vec4 diffuseColor;
	vec4 specularColor;
	vec4 reflectedColor;
	vec4 tranparencyColor;
};


struct LightData {
	int type;
	vec4 color;
};


// TODO: shadows
int checkOcclusions(inout SurfaceElement surfel, inout LightData lightData) {
	return 0;
}


// TODO: reflections and refractions
vec4 estimateIndirectLight(inout SurfaceElement surfel, inout Ray ray) {

	return vec4(0.f);
}


// TODO: diffuse and specular
vec4 estimateDirectLight(inout SurfaceElement surfel, inout Ray ray) {
	
	vec4 kdOd = surfel.diffuseColor;
	vec4 ksOs = surfel.specularColor;

	return vec4(0.f);

}


vec2 getQuadradicRoots(float A, float B, float C) {
	float det = B*B - 4*A*C;
	
	det = det*float(det > 0.f) + pow(10.f, 5.f)*float(det < 0.f);
	float t1 = (-B + sqrt(det))/(2.f*A);
	float t2 = (-B - sqrt(det))/(2.f*A);

	return vec2(t1, t2);
}


float sphereRayIntersect(inout Ray ray) {
	vec4 P = ray.P;
	vec4 d = ray.d;

	float A = pow(d.x, 2.f) + pow(d.y, 2.f) + pow(d.z, 2.f);
	float B = 2.f*(P.x*d.x + P.y*d.y + P.z*d.z);
	float C = pow(P.x, 2.f) + pow(P.y, 2.f) + pow(P.z, 2.f) - 0.25;

	vec2 tVals = getQuadradicRoots(A, B, C);


	return min(tVals.x, tVals.y);
}


// TODO: how to represent the scene, I'm thinking hardcoded SDF like lab 10
int intersect(inout Ray ray, inout SurfaceElement surfel) {
	
	// TODO: remove, simple sphere ray intersect test
	
	float t = sphereRayIntersect(ray);
	if (t < MAX_VAL) {
		// TODO: paint surfel here
		return 1;

	}
	return 0;
}


// inout is how you pass by ref in glsl
vec4 traceRay(inout Ray ray, int depth) {

	SurfaceElement surfel;
	int isIntersect = intersect(ray, surfel);

	vec4 radiance = vec4(0.f, 0.f, 0.f, 1.f);
	// TODO: restore when ready
	if (isIntersect == 1) {
		radiance = estimateDirectLight(surfel, ray) + estimateIndirectLight(surfel, ray);
	}

	if (isIntersect == 1) {
		radiance = vec4(1.f, 0.f, 0.f, 1.f); // red sphere for now
	} 
	
	return radiance;
};



void main() {
	vec4 pixel = vec4(0.f, 0.f, 0.f, 1.f); //black

	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 dims = imageSize(renderOut);
	
	float x = ((2.f*float(pixelCoords.x))/dims.x) - 1.f;
	float y = ((2.f*float(pixelCoords.y))/dims.y) - 1.f;

	vec4 radiance = vec4(0.f, 0.f, 0.f, 1.f);

//	if (y < 0) {
//		fragColor += vec4(1.f, 0.f, 0.f, 0.f); // negative x should be more red
//	} else if (y > 0)  {
//		fragColor += vec4(0.f, 1.f, 0.f, 0.f); // positiive x should be more green
//	}

	vec4 pt_film = vec4(x, y, 0.f, 1.f);
	vec4 pt_world = M_film2World*pt_film;

//	vec4 d = normalize(pt_world - eye);
	vec4 d = vec4(0.f, 0.f, -1.f, 0.f);
	vec4 P = vec4(x, y, 0.f, 1.f);

	vec4 sphereCenter = vec4(0.f, 0.f, -10.f, 1.f);
	float R = 1.f;

	float A = pow(d.x, 2.f) + pow(d.y, 2.f) + pow(d.z, 2.f);
	float B = 2.f*(P.x*d.x + P.y*d.y + P.z*d.z);
	float C = pow(P.x, 2.f) + pow(P.y, 2.f) + pow(P.z, 2.f) - 0.25;

	float det = B*B - 4*A*C;
	if (det >= 0.f) {
		pixel = vec4(1.f, 0.f, 0.f, 1.f);
	} else {
		pixel = vec4(0.f, 0.f, 0.f, 1.f);
	}

//	float x = (2.f*float(col))/dims.x - 1.f;
//	float y = 1.f - (2*float(row))/dims.y;
//
//	vec4 pt_film = vec4(x, y, 0.f, 1.f);
//	vec4 pt_world = M_film2World*pt_film;
//
//	vec4 d = normalize(pt_world - eye);
//	vec4 P = eye;

	// TODO: restore
	// Ray ray;
	// ray.P = P;
	// ray.d = d;
	// pixel = traceRay(ray, depth);

	// TODO: remove debugging line: should make a blue circle on the screen
//	P = vec4(x, y, 0.f, 0.f);
//	d = vec4(0.f, 0.f, -1.f, 0.f);
//	vec4 sphereCenter =	vec4(0.f, 0.f, -10.f, 0.f);
//	float R = 1.f;
//	vec4 camToSphere = P - sphereCenter;
//	float B = dot(d, camToSphere);
//	float C = dot(camToSphere, camToSphere) - R*R;
//	float det = B*B - C;
//	if (det >= 0.f) {
//		pixel = vec4(0.f, 0.f, 1.0, 1.0); // blue spehere it works
//	}

	// pixel = vec4(1.f, 0.f, 0.f, 1.f);

	// // TODO: remove debugging line: should make everything red if works
	// pixel = vec4(1.f, 0.f, 0.f, 1.f);

	// modified renderOut
	imageStore(renderOut, pixelCoords, pixel);
}


